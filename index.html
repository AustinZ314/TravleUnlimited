<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Austin Zhang">
    <title>travle unlimited</title>

    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
</head>
<body>
    
    <!-- Create an element where the map will take place -->
    <svg id="map" width="600" height="400"></svg> <br>

    <input id="userInput"> <br> <br>
    <button onclick="addCountry()">Submit</button>
    <button onclick="restart()">Restart</button>

    <style>
        body {background-color: darkslategray; text-align: center; color: brown;}
    </style>

    <script>
        // The svg
        const svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");
                
        // Map and projection
        const projection = d3.geoMercator()
            .center([2, 47])
            .scale(width / 1.5 / Math.PI)
            .translate([width / 2, height / 2]);
        
        var currentDisplay = []; // List of displayed countries
        var path = []; // Shortest path between start and target countries

        document.addEventListener('DOMContentLoaded', async function() {
            var graph = await fetch('./neighbors.json');
            const data = await graph.json();
            var endpoints = randomCountry(data.features);
            console.log(endpoints);
            
            path = findShortestPath(data.features, endpoints[0], endpoints[1]);
            path = findAlternatePaths(data.features);
            while(path.length === 0 || path[0].length <= 3) {
                endpoints = randomCountry(data.features);
                console.log(endpoints);
                path = findShortestPath(data.features, endpoints[0], endpoints[1]);
            }
            console.log(path);
            currentDisplay.push(endpoints[0], endpoints[1]);
            displayCountry(endpoints[0]);
            displayCountry(endpoints[1]);
        })

        function addCountry() {
            var countryID = document.querySelector("#userInput");
            if(!currentDisplay.includes(countryID)) {
                currentDisplay.push(countryID.value);
            }
            displayCountry(countryID.value);
            
            const checkWin = (displayedCountry) => Array.isArray(displayedCountry) ? displayedCountry.some(checkWin): currentDisplay.includes(displayedCountry);

            if(path.every(checkWin)) {
                console.log("You win!");
            }
        }
        
        function randomCountry(graph) {
            var startIndex = Math.floor(Math.random()*177);
            var targetIndex = Math.floor(Math.random()*177);
            while(startIndex === targetIndex) targetIndex = Math.floor(Math.random()*177);
            const startCountry = graph[startIndex].id;
            const targetCountry = graph[targetIndex].id;
            return [startCountry, targetCountry];
        }
        
        // Add given country to the svg by fetching map data and filtering for selected country
        function displayCountry(countryName) {
            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(function(data) {
                var newCountry = data.features.find(country => country.properties.name === countryName)
                svg.append("g")
                    .selectAll("path")
                    .data([newCountry])
                    .join("path")
                    .attr("fill", "#69b3a2")
                    .attr("d", d3.geoPath()
                        .projection(projection))
                    .style("stroke", "#fff");
            });
        }

        // Use dijkstra's algorithm to find shortest path from start to target
        // Each country is represented by a node
        // Neighboring countries have a distance of 1
        function findShortestPath(graph, start, target) {
            var dist = {};
            var prev = {};
            var vertices = [];
            for (var i = 0; i < graph.length; i++) {
                var vertex = graph[i];
                dist[vertex.id] = Infinity;
                prev[vertex.id] = null;
                vertices.push(vertex);
            }
            dist[start] = 0;

            // Find the vertex having smallest distance from start country
            while (vertices.length > 0) {
                var u = vertices.reduce(function(p, current) {return !p || dist[current.id] < dist[p.id] ? current : p;}, null);
                const index = vertices.indexOf(u);
                vertices.splice(index, 1);
                if (u.neighbors && Array.isArray(u.neighbors)) {
                    for (let i = 0; i < u.neighbors.length; i++) {
                        var v = u.neighbors[i];
                        const alt = dist[u.id] + 1;
                        if (alt < dist[v]) {
                            dist[v] = alt;
                            prev[v] = u;
                        }
                    }
                }
            }

            var result = [];
            while (target) {
                result.splice(0, 0, target);
                target = prev[target] ? prev[target].id : null;
            }

            // Any empty array return means there is no path. For example one of the countries is an island.
            if (result.length === 1) {
                return [];
            }
            return result;
        }

        // Look for alternative paths with the same length as the shortest path
        function findAlternatePaths(graph) {
            var newPath = path;
            for(let i = 1; i < path.length - 1; i++) {
                var neighbors = graph.find(country => country.id === path[i]).neighbors;
                for(let j = 0; j < neighbors.length; j++) {
                    var neighborsOfNeighbor = graph.find(country => country.id === neighbors[j]).neighbors;
                    if(neighborsOfNeighbor.includes(path[i - 1]) && neighborsOfNeighbor.includes(path[i + 1])) {
                        newPath[i] = [path[i], neighbors[j]];
                    }
                }
            }
            return newPath;
        }

        // Clear current display and select two new countries to play again
        async function restart() {
            svg.selectAll("path").remove();
            currentDisplay = [];
            path = [];
            var graph = await fetch('./neighbors.json');
            const data = await graph.json();
            var endpoints = randomCountry(data.features);
            console.log(endpoints);
            
            path = findShortestPath(data.features, endpoints[0], endpoints[1]);
            while(path.length === 0 || path[0].length <= 3) {
                endpoints = randomCountry(data.features);
                console.log(endpoints);
                path = findShortestPath(data.features, endpoints[0], endpoints[1]);
            }
            console.log(path);
            currentDisplay.push(endpoints[0], endpoints[1]);
            displayCountry(endpoints[0]);
            displayCountry(endpoints[1]);
        }
        
    </script>
</body>
</html>